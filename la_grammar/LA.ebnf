@@grammar::LA
@@whitespace :: /(?!.*)/     #parse whitespace manually
@@left_recursion::True

start::Start
    =
    {separator_with_space} stat:statements {separator_with_space}+ WHERE {separator_with_space}+ cond:where_conditions {blank} $
    ;

#include :: "linear_algebra/la_grammar/keywords.ebnf"
#include :: "linear_algebra/la_grammar/number.ebnf"
#include :: "linear_algebra/la_grammar/operators.ebnf"
#include :: "linear_algebra/la_grammar/matrix.ebnf"
#include :: "linear_algebra/la_grammar/base.ebnf"



statements::Statements
    =
    | {hspace} value+:statements {separator_with_space}+ value+:statement {hspace}
    | {hspace} value+:statement {hspace}
    ;

statement
    =
    | assignment
    | expression
    ;

where_conditions::WhereConditions
    = {hspace} value+:where_conditions {separator_with_space}+ value+:where_condition
    | {hspace} value+:where_condition {hspace}
    ;

where_condition
    = matrix_condition
    | vector_condition
    | scalar_condition
    ;

matrix_condition::MatrixCondition
    = id:identifier {hspace} ':' {hspace} 'matrix' {hspace} '(' {hspace} id1:(integer | identifier)  {hspace} ',' {hspace} id2:(integer | identifier) {hspace}')'  {{hspace}+ attr+:matrix_attribute}  { {hspace} ':' {hspace} desc:description}
    | id:identifier {hspace} ':' {hspace} type:('ℝ'|'ℕ') {hspace} '^' {hspace} '(' {hspace} id1:(integer | identifier)  {hspace} '✖' {hspace} id2:(integer | identifier) {hspace}')'  {{hspace}+ attr+:matrix_attribute}  { {hspace} ':' {hspace} desc:description}
    ;

matrix_attribute
    = SYMMETRIC
    | DIAGONAL
    ;

vector_condition::VectorCondition
    = id:identifier {hspace} ':' {hspace} 'vector' {hspace} '(' {hspace} id1:(integer | identifier) {hspace}')' { {hspace} ':' {hspace} desc:description}
    | id:identifier {hspace} ':' {hspace} type:('ℝ'|'ℕ') {hspace} '^' {hspace} '(' {hspace} id1:(integer | identifier) {hspace}')' { {hspace} ':' {hspace} desc:description}
    | id:identifier {hspace} ':' {hspace} type:('ℝ'|'ℕ') {hspace} '^' {hspace} id1:(integer | identifier) { {hspace} ':' {hspace} desc:description}
    ;

scalar_condition::ScalarCondition
    = id:identifier {hspace} ':' {hspace} 'scalar' { {hspace} ':' {hspace} desc:description}
    ;

expression
    =
    | addition
    | subtraction
    | term
    #| {}
    ;

assignment::Assignment
    =
    left:identifier {hspace} '=' {hspace} {separator_with_space} right:expression {hspace}
    ;

term
    =
    | multiplication
    | division
    | factor
    ;

factor::Factor
    =
    | '+' f:factor
    | '-' f:factor
    | op:operations
    | sub:subexpression
    | id:identifier
    | num:number
    | m:matrix
    ;

subexpression::Subexpression
    =
    '(' {hspace} value:expression {hspace} ')'
    ;