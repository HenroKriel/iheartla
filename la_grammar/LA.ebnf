@@grammar::LA
@@whitespace :: /(?!.*)/     #parse whitespace manually
@@left_recursion::True

start::Start
    =
    | {separator_with_space} directive+:Directive {{separator_with_space}+ directive+:Directive}
    | {separator_with_space} {directive+:Directive {{separator_with_space}+ directive+:Directive} {separator_with_space}+} stat:statements
    {{separator_with_space}+ WHERE {separator_with_space}+ cond:where_conditions} {blank} $
    ;

#include :: "linear_algebra/la_grammar/keywords.ebnf"
#include :: "linear_algebra/la_grammar/number.ebnf"
#include :: "linear_algebra/la_grammar/operators.ebnf"
#include :: "linear_algebra/la_grammar/matrix.ebnf"
#include :: "linear_algebra/la_grammar/base.ebnf"
#include :: "linear_algebra/la_grammar/trigonometry.ebnf"


KEYWORDS
    = BUILTIN_KEYWORDS
    ;

builtin_operators
    =
    predefined_built_operators
    ;

statements::Statements
    =
    | {hspace} stats:statements {separator_with_space}+ stat:statement {hspace}
    | {hspace} stat:statement {hspace}
    ;

statement
    =
    | assignment
    | right_hand_side
    ;

Directive
    = import
    ;

import::Import
    = FROM  {hspace}+ package:keyword_str {hspace} ':' {hspace} names+:keyword_str {{hspace} ',' {hspace} names+:keyword_str }
    ;

where_conditions::WhereConditions
    = {hspace} value+:where_condition {{separator_with_space}+ value+:where_condition}
    ;

where_condition::WhereCondition
    = id:identifier {hspace} ':' {hspace} type:la_type { {hspace} ':' {hspace} desc:description}
    ;

matrix_type::MatrixType
    = 'matrix' {hspace} '(' {hspace} id1:dimension  {hspace} ',' {hspace} id2:dimension {hspace}')'  {{hspace}+ attr+:matrix_attribute}
    | type:('ℝ'|'ℤ') {hspace} '^' {hspace} '(' {hspace} id1:dimension  {hspace} '×' {hspace} id2:dimension {hspace}')'  {{hspace}+ attr+:matrix_attribute}
    ;

matrix_attribute
    = SYMMETRIC
    | DIAGONAL
    ;

vector_type::VectorType
    = 'vector' {hspace} '(' {hspace} id1:dimension {hspace}')'
    | type:('ℝ'|'ℤ') {hspace} '^' {hspace} '(' {hspace} id1:dimension {hspace}')'
    | type:('ℝ'|'ℤ') {hspace} '^' {hspace} id1:dimension
    ;

scalar_type::ScalarType
    = 'scalar'
    | 'ℝ'
    | z:'ℤ'
    ;

set_type::SetType
    = '{' {hspace} type+:('ℝ'|'ℤ') {hspace} {'×' {hspace} type+:('ℝ'|'ℤ') {hspace} }'}'
    | '{' {hspace} type1:('ℝ'|'ℤ') {hspace} '^' {hspace} cnt:(integer) {hspace} '}'
    | '{' {hspace} type2:(/\u211D/ | /\u2124/) cnt:{/[\u2070\u00B9\u00B2\u00B3\u2074-\u2079]/} {hspace} '}'     #  \u2124:ℤ  \u211D:ℝ
    ;

dimension
    =
    integer | identifier
    #expression
    ;

la_type
    =
    | function_type
    | matrix_type
    | vector_type
    | set_type
    | scalar_type
    ;

params_type
    = matrix_type
    | vector_type
    | scalar_type
    ;

function_type::FunctionType
    = ((params+:params_type {{hspace} params_separator {hspace} params+:params_type})|'∅'|'{'{hspace}'}') {hspace} ('→'|'->') {hspace} ret:params_type
    ;

expression::Expression
    =
    | value:addition
    | value:subtraction
    | value:add_sub_operator
    | sign:['-'] value:term
    #| {}
    ;

assignment::Assignment
    =
    left:identifier {hspace} op:'=' {hspace} {separator_with_space} right:right_hand_side {hspace}
    | left:identifier {hspace} op:'+=' {hspace} {separator_with_space} right:right_hand_side {hspace}
    ;

right_hand_side
    =
    | expression
    | optimize_operator
    ;

term
    =
    | multiplication
    | division
    | factor
    ;

factor::Factor
    =
    | op:operations
    | sub:subexpression
    | nm:number_matrix
    | id:identifier
    | num:number
    | m:matrix
    | s:sparse_matrix
    | c:constant
    ;

subexpression::Subexpression
    =
    '(' {hspace} value:expression {hspace} ')'
    ;

if_condition::IfCondition
    =
    | cond:not_equal
    | cond:equal
    | cond:in
    | cond:not_in
    | cond:greater
    | cond:greater_equal
    | cond:less
    | cond:less_equal
    ;

in::InCondition
    = '(' {hspace} left+:expression {hspace} {',' {hspace} left+:expression {hspace}} ')' {hspace} IN {hspace} right:identifier
    | left+:expression {hspace} IN {hspace} right:identifier
    ;

not_in::NotInCondition
    = '(' {hspace} left+:expression {hspace} {',' {hspace} left+:expression {hspace}} ')' {hspace} '∉' {hspace} right:identifier
    | left+:expression {hspace} '∉' {hspace} right:identifier
    ;

not_equal::NeCondition
    = left:expression {hspace} ('≠' | '!=') {hspace} right:expression
    ;

equal::EqCondition
    = left:expression {hspace} ('==' | '=') {hspace} right:expression
    ;

greater::GreaterCondition
    = left:expression {hspace} '>' {hspace} right:expression
    ;

greater_equal::GreaterEqualCondition
    = left:expression {hspace} ('>=' | '⩾') {hspace} right:expression
    ;

less::LessCondition
    = left:expression {hspace} '<' {hspace} right:expression
    ;

less_equal::LessEqualCondition
    = left:expression {hspace} ('<=' | '⩽') {hspace} right:expression
    ;
